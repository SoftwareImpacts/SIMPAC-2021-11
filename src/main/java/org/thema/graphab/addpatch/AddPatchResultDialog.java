/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.thema.graphab.addpatch;

import org.thema.graphab.graph.GraphGenerator;
import com.vividsolutions.jts.geom.Coordinate;
import com.vividsolutions.jts.geom.GeometryFactory;
import com.vividsolutions.jts.geom.Point;
import java.awt.BorderLayout;
import java.awt.EventQueue;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.io.File;
import java.io.FileWriter;
import java.util.*;
import java.util.concurrent.CancellationException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import org.geotools.coverage.grid.GridCoverage2D;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import org.thema.common.Config;
import org.thema.common.TreeMapList;
import org.thema.common.distribute.ExecutorService;
import org.thema.common.io.IOImage;
import org.thema.common.parallel.ParallelFExecutor;
import org.thema.common.parallel.ProgressBar;
import org.thema.common.parallel.SimpleParallelTask;
import org.thema.common.parallel.TaskMonitor;
import org.thema.common.parallel.TaskMonitor.EmptyMonitor;
import org.thema.drawshape.feature.DefaultFeature;
import org.thema.drawshape.feature.Feature;
import org.thema.drawshape.layer.DefaultGroupLayer;
import org.thema.drawshape.layer.FeatureLayer;
import org.thema.graphab.MainFrame;
import org.thema.graphab.Project;
import org.thema.graphab.metric.GraphMetricLauncher;
import org.thema.graphab.metric.global.GlobalMetric;

/**
 *
 * @author gvuidel
 */
public class AddPatchResultDialog extends javax.swing.JDialog {

    MainFrame mainFrame;
    DefaultGroupLayer layers;
    /**
     * Creates new form AddPatchResultDialog
     */
    public AddPatchResultDialog(MainFrame parent) {
        super(parent, true);
        initComponents();
        setLocationRelativeTo(parent);
        mainFrame = parent;
        
        layers = new DefaultGroupLayer("Results");
        layers.addLayerFirst(new FeatureLayer("Patches", Project.getProject().getPatches()));
        mapViewer1.setRootLayer(layers);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        closeButton = new javax.swing.JButton();
        jSplitPane1 = new javax.swing.JSplitPane();
        mapViewer1 = new org.thema.drawshape.ui.MapViewer();
        graphPanel = new javax.swing.JPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
        setTitle("Add patches");

        closeButton.setText("Close");
        closeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                closeButtonActionPerformed(evt);
            }
        });

        jSplitPane1.setDividerLocation(500);
        jSplitPane1.setResizeWeight(0.5);
        jSplitPane1.setLeftComponent(mapViewer1);

        graphPanel.setLayout(new java.awt.BorderLayout());
        jSplitPane1.setRightComponent(graphPanel);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(closeButton, javax.swing.GroupLayout.PREFERRED_SIZE, 75, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
            .addComponent(jSplitPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 1008, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addComponent(jSplitPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 481, Short.MAX_VALUE)
                .addGap(6, 6, 6)
                .addComponent(closeButton)
                .addGap(6, 6, 6))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void closeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_closeButtonActionPerformed
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                setVisible(false);
                dispose();
                mainFrame.reloadProject();
            }
        });
        
    }//GEN-LAST:event_closeButtonActionPerformed

    public void addPatches(final int nbPatch, final File pointFile, final String capaField, final GlobalMetric indice, final GraphGenerator gen) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                ProgressBar bar = Config.getProgressBar();
                bar.setNote("Add patches...");
                try {
                    TreeMap<Integer, Double> indiceValues = new TreeMap<Integer, Double>();
                    List<DefaultFeature> addedPatches = addPatchShp(nbPatch, indice, gen, pointFile, capaField, bar, indiceValues, layers);
                    
                    showResults(indice, gen, addedPatches, indiceValues);
                    saveResults(indice, gen, addedPatches, indiceValues, 0, 0, 0);
                } catch(CancellationException cancel) {
                    closeButtonActionPerformed(null);
                } catch(Exception ex) {
                    Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE, null, ex);
                    JOptionPane.showMessageDialog(AddPatchResultDialog.this, ex);
                    closeButtonActionPerformed(null);
                } finally {
                    bar.close();
                }
            }
        }).start();
        
        setVisible(true);
    }
   
    public void addPatches(final int nbPatch, final double res, final File capaFile, final GlobalMetric indice, final GraphGenerator gen,
            final int nbMultiPatch, final int windowMulti) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                ProgressBar bar = Config.getProgressBar();
                bar.setNote("Add patches...");
                TaskMonitor mon = new TaskMonitor(AddPatchResultDialog.this, "Add patches", "", 0, 100);
                try {
                    
                    TreeMap<Integer, Double> indiceValues = new TreeMap<Integer, Double>();
                    
                    List<DefaultFeature> addedPatches = addPatchGrid(nbPatch, indice, gen, capaFile, res, nbMultiPatch, windowMulti, 
                            mon, indiceValues, layers);
                    
                    showResults(indice, gen, addedPatches, indiceValues);
                    saveResults(indice, gen, addedPatches, indiceValues, res, windowMulti, windowMulti);
                } catch(CancellationException cancel) {
                    closeButtonActionPerformed(null);
                } catch(Exception ex) {
                    Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE, null, ex);
                    JOptionPane.showMessageDialog(AddPatchResultDialog.this, ex);
                    closeButtonActionPerformed(null);
                } finally {
                    mon.close();
                }

            }
        }).start();
        
        setVisible(true);
    }
    
    private void showResults(GlobalMetric indice, GraphGenerator gen, List<DefaultFeature> addedPatches, TreeMap<Integer, Double> indiceValues) {
        XYSeries serie = new XYSeries("Serie");
        for(Integer nbPatch : indiceValues.keySet())
            serie.add(nbPatch, indiceValues.get(nbPatch));
        JFreeChart chart = ChartFactory.createXYLineChart(null, "# added patch", indice.getDetailName(), 
                new XYSeriesCollection(serie), PlotOrientation.VERTICAL, false, false, false);
        ((NumberAxis)chart.getXYPlot().getRangeAxis()).setAutoRangeIncludesZero(false);
        ChartPanel chartPanel = new ChartPanel(chart);
        graphPanel.add(chartPanel, BorderLayout.CENTER);

        layers.addLayerFirst(new FeatureLayer("Patches added", addedPatches));
        layers.addLayerLast(new GraphGenerator(gen, "").getLayers());
    }
    
    
    private static List<DefaultFeature> addPatchSimple(int nbPatch, final HashMap<Coordinate, Double> testPoints, final GlobalMetric indice, final GraphGenerator gen, 
            ProgressBar mon, TreeMap<Integer, Double> indiceValues, DefaultGroupLayer layers) throws Exception {
        
        Project project = Project.getProject();

        mon.setMaximum(nbPatch);

        List<DefaultFeature> addedPatches = new ArrayList<DefaultFeature>();
            
        double currentInd = new GraphMetricLauncher(indice, true).calcIndice(gen, new EmptyMonitor())[0];
        indiceValues.put(0, currentInd);
        mon.incProgress(1);
        Logger.getLogger(AddPatchResultDialog.class.getName()).log(Level.INFO, "Initial " + indice.getShortName() + " : " + currentInd); 
        
        Point bestPoint = null;
        double capaPoint = 0;
        
        for(int i = 0; i < nbPatch; i++) {
            AddPatchTask task = new AddPatchTask(bestPoint, capaPoint, gen, indice, testPoints, mon.getSubProgress(1));
            ExecutorService.execute(task);
            TreeMapList<Double, Point> pointIndices = task.getResult();
            
            List<Point> bestPoints = pointIndices.lastEntry().getValue();
            bestPoint = bestPoints.get((int)(Math.random()*bestPoints.size()));

            int step = i+1;
            capaPoint = testPoints.get(bestPoint.getCoordinate());
            DefaultFeature patch = project.addPatch(bestPoint, capaPoint);
            gen.getCostDistance().addLinks(patch);
            
            patch = new DefaultFeature(patch, true, true);
            patch.addAttribute("Etape", step);
            patch.addAttribute("delta-" + indice.getDetailName(), pointIndices.lastKey()-currentInd);
            patch.addAttribute(indice.getDetailName(), pointIndices.lastKey());
            addedPatches.add(patch);
            
            indiceValues.put(addedPatches.size(), pointIndices.lastKey());
            currentInd = pointIndices.lastKey();
            
            if(layers != null) {
                List<DefaultFeature> debug = new ArrayList<DefaultFeature>();
                for(Double val : pointIndices.keySet())
                    for(Point p : pointIndices.get(val)) {
                        debug.add(new DefaultFeature(p.getX()+","+p.getY()+" - " + (step), p, Arrays.asList("Etape", indice.getDetailName()), 
                                Arrays.asList(step, val)));
                    }
                layers.addLayerFirst(new FeatureLayer("Debug " + step, debug));
            }

            Logger.getLogger(AddPatchResultDialog.class.getName()).log(Level.INFO, 
                    "Step " + step + " : 1 added patches " + bestPoint.getCoordinate() + " from " + bestPoints.size() + " best points  for " + indice.getShortName() + " = " + pointIndices.lastKey()); 
        }

        return addedPatches;
    }
    
    public static List<DefaultFeature> addPatchShp(int nbPatch, GlobalMetric indice, GraphGenerator gen, File pointFile, String capaField,
            ProgressBar bar, TreeMap<Integer, Double> indiceValues, DefaultGroupLayer layers) throws Exception {

        List<DefaultFeature> points = DefaultFeature.loadFeatures(pointFile, false);
        HashMap<Coordinate, Double> testPoints = new HashMap<Coordinate, Double>();
        for(Feature f : points)
            testPoints.put(f.getGeometry().getCentroid().getCoordinate(), 
                    capaField == null ? 1 : ((Number)f.getAttribute(capaField)).doubleValue());

        return addPatchSimple(nbPatch, testPoints, indice, gen, bar, indiceValues, layers);
    }
    
    public static List<DefaultFeature> addPatchGrid(int nbPatch, GlobalMetric indice, GraphGenerator gen, File capaFile, 
            double res, int nbMultiPatch, int windowSize, 
            TaskMonitor mon, TreeMap<Integer, Double> indiceValues, DefaultGroupLayer layers) throws Exception {
        
        Project project = Project.getProject();
        Rectangle2D rect = project.getZone();
        double dx = rect.getWidth() - Math.floor((rect.getWidth()) / res) * res;
        double dy = rect.getHeight() - Math.floor((rect.getHeight()) / res) * res;
        rect = new Rectangle2D.Double(rect.getX()+dx/2, rect.getY()+dy/2,
            rect.getWidth()-dx, rect.getHeight()-dy);
        
        GridCoverage2D capaCov = null;
        try {
            if(capaFile != null)
                capaCov = capaFile.getName().toLowerCase().endsWith(".tif") ? IOImage.loadTiff(capaFile) : IOImage.loadArcGrid(capaFile);
            
            HashMap<Coordinate, Double> testPoints = new HashMap<Coordinate, Double>();
            for(double y = rect.getMinY()+res/2; y < rect.getMaxY(); y += res) 
                for(double x = rect.getMinX()+res/2; x < rect.getMaxX(); x += res) 
                    testPoints.put(new Coordinate(x, y), capaCov == null ? 1 : capaCov.evaluate(new Point2D.Double(x, y), new double[1])[0]);
            
            if(nbMultiPatch <= 1) 
                return addPatchSimple(nbPatch, testPoints, indice, gen, mon, indiceValues, layers);
            
            // sinon on continue avec la version multipatch
            mon.setMaximum((int)(nbPatch*rect.getWidth()/res*rect.getHeight()/res));
            mon.popupNow();
            double currentInd = new GraphMetricLauncher(indice, true).calcIndice(gen, new EmptyMonitor())[0];
            indiceValues.put(0, currentInd);
            
            Logger.getLogger(AddPatchResultDialog.class.getName()).log(Level.INFO, "Initial " + indice.getShortName() + " : " + currentInd); 
            List<DefaultFeature> addedPatches = new ArrayList<DefaultFeature>();
            HashMap<Point, Double> lastAddedPoints = new HashMap<Point, Double>();
            for(int i = 0; addedPatches.size() < nbPatch; i++) {
                int step = i+1;
                TreeMapList<Double, Set<Point>> pointIndices;
                
                if(ExecutorService.isMPIExecutor()) {
                    AddPatchMultiMPITask task = new AddPatchMultiMPITask(
                            lastAddedPoints, gen, indice, currentInd, res, nbMultiPatch, windowSize, 
                            new ArrayList<Coordinate>(testPoints.keySet()), capaCov, mon.getSubProgress(1));
                    ExecutorService.execute(task);
                    pointIndices = task.getResult();
                } else {
                    pointIndices = new TreeMapList<Double, Set<Point>>();
                    for(Coordinate coord : testPoints.keySet()) {
                        if(mon.isCanceled())
                            throw new CancellationException();
                        Point p = new GeometryFactory().createPoint(coord);
                        addPatchWindow(new LinkedList<Point>(Arrays.asList(p)), indice, gen, capaCov, 
                            currentInd, res, nbMultiPatch, windowSize, pointIndices, nbMultiPatch);
                        mon.incProgress(1);
                    }
                }

                lastAddedPoints.clear();
                List<Set<Point>> bestPoints = pointIndices.lastEntry().getValue();
                Set<Point> bests = bestPoints.get((int)(Math.random()*bestPoints.size()));
                currentInd += pointIndices.lastKey()*bests.size();
                
                for(Point best : bests) {
                    double capa = capaCov == null ? 1 : capaCov.evaluate(new Point2D.Double(best.getX(), best.getY()), new double[1])[0];
                    DefaultFeature patch = project.addPatch(best, capa);
                    gen.getCostDistance().addLinks(patch);
                    patch = new DefaultFeature(patch, true, true);
                    patch.addAttribute("Etape", step);
                    patch.addAttribute("delta-" + indice.getDetailName(), pointIndices.lastKey());
                    patch.addAttribute(indice.getDetailName(), currentInd);
                    addedPatches.add(patch);
                    lastAddedPoints.put(best, capa);
                }

                indiceValues.put(addedPatches.size(), currentInd);
                
                if(layers != null) {
                    List<DefaultFeature> debug = new ArrayList<DefaultFeature>();
                    for(Point p : bests) 
                        debug.add(new DefaultFeature(p.getX()+","+p.getY()+" - " + (step), p, Arrays.asList("Etape", indice.getDetailName()), 
                                Arrays.asList(step, currentInd)));
                        
                    layers.addLayerFirst(new FeatureLayer("Debug " + (i+1), debug));
                }

                Logger.getLogger(AddPatchResultDialog.class.getName()).log(Level.INFO, 
                        "Step " + step + " : " + bests.size() + " added patches" + " from " + bestPoints.size() + " best points sets  for " + indice.getShortName() + " = " + pointIndices.lastKey()); 
            }
            
            return addedPatches;
        } finally {
            if(capaCov != null)
                capaCov.dispose(true);
        }
    }
    
    public static void saveResults(GlobalMetric indice, GraphGenerator graph, List<DefaultFeature> addedPatches, TreeMap<Integer, Double> indiceValues,
            double res, int nbMulti, int window) throws Exception {
        String name = graph.getName() + "_" + indice.getDetailName();
        File dir = new File(Project.getProject().getProjectDir(), "addpatch_n" + addedPatches.size() + "_" + indice.getShortName() + "_res" + res + "_multi" + nbMulti + "_" + window);
        dir.mkdir();
        FileWriter w = new FileWriter(new File(dir, "addpatch-" + name + ".txt"));
        w.write("#patch\tDelta indice\n");
        for(Integer nbP : indiceValues.keySet())
            w.write(nbP + "\t" + indiceValues.get(nbP) + "\n");
        w.close();

        DefaultFeature.saveFeatures(addedPatches, new File(dir, "addpatch-" + name + ".shp"));
        GraphGenerator newGraph = new GraphGenerator(graph, "");
        DefaultFeature.saveFeatures(newGraph.getLinks(), new File(dir, "links-" + name + ".shp"));
        newGraph.getLayers().getEdgeLayer().exportToShapefile(new File(dir, "topo-links-" + name + ".shp"));
        
    }
    
    private static void addPatchWindow(final LinkedList<Point> points, final GlobalMetric indice, final GraphGenerator gen, final GridCoverage2D capaCov, 
            final double indInit, double res, int nbMultiPatch, int windowSize,
            final TreeMapList<Double, Set<Point>> pointIndices, int level) throws Exception {
        Project project = Project.getProject();
        Point point = points.getLast();
        if(!project.canCreatePatch(point))
            return ;
        double capa = capaCov == null ? 1 : capaCov.evaluate(new Point2D.Double(point.getX(), point.getY()), new double[1])[0];
        if(capa <= 0)
            return ;
        DefaultFeature patch = project.addPatch(point, capa);
        gen.getCostDistance().addLinks(patch);
        GraphGenerator graph = new GraphGenerator(gen, "");
        double indVal = (new GraphMetricLauncher(indice, true).calcIndice(graph, new EmptyMonitor())[0]
                - indInit) / points.size();
        pointIndices.putValue(indVal, new HashSet<Point>(points));
        
        // si c'est le premier voisinage on ne calcule que la moitié (à partir du centre) 
        // sinon on calcule pour tout le voisinage (peut être amélioré mais pas évident)
        double x = point.getX() - (level != nbMultiPatch ? windowSize*res : 0);
        double y = point.getY() - (level != nbMultiPatch ? windowSize*res : 0);
        List<Point> coords = new ArrayList<Point>();
        for(; y <= point.getY()+windowSize*res; y += res) {
            for(; x <= point.getX()+windowSize*res; x += res)
                if(x != point.getX() || y != point.getY())
                    coords.add(new GeometryFactory().createPoint(new Coordinate(x, y)));
            // on redémarre complètement à gauche pas comme à l'initial (si level == nbMultiPatch)
            x = point.getX() - windowSize*res;
        }
        
        // si il ne reste qu'un voisinage à tester on le fait en soft pour le paralléliser sinon on récurre
        if(level == 2)       
            new ParallelFExecutor(new SimpleParallelTask<Point>(coords) {
                @Override
                protected void executeOne(Point p) {
                    try {
                        double indVal = AddPatchTask.addPatchSoft(p, indice, gen, capaCov);
                        if(!Double.isNaN(indVal)) {
                            HashSet<Point> pointSet = new HashSet<Point>(points);
                            pointSet.add(p);
                            synchronized(pointIndices) {
                                pointIndices.putValue((indVal-indInit)/pointSet.size(), pointSet);
                            }
                        }
                    } catch (Exception ex) {
                        throw new RuntimeException(ex);
                    }
                }
            }).executeAndWait();
        else // sinon on récurre
           for(Point p : coords) {
                points.addLast(p);
                addPatchWindow(points, indice, gen, capaCov, indInit, res, nbMultiPatch, windowSize, pointIndices, level-1);
                points.removeLast();
            }
                
        gen.getCostDistance().removeLinks(patch);
        project.removePatch(patch);
        
    }
    
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton closeButton;
    private javax.swing.JPanel graphPanel;
    private javax.swing.JSplitPane jSplitPane1;
    private org.thema.drawshape.ui.MapViewer mapViewer1;
    // End of variables declaration//GEN-END:variables
}
